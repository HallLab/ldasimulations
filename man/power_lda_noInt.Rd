% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/power_lda_noInt.R
\name{power_lda_noInt}
\alias{power_lda_noInt}
\title{Generate and analyze longitudinal data with
a nonvarying predictor effect over time}
\usage{
power_lda_noInt(
  clus = 50,
  waves = 3,
  gvar = 1,
  ivar = 1,
  xVary = F,
  yType = 1,
  b0 = 1,
  b1 = 1,
  b2 = 1
)
}
\arguments{
\item{clus}{Numeric. Number of clusters. Default is 50.}

\item{waves}{Numeric. Number of timepoints per sample. Default is 3.}

\item{gvar}{Numeric. Group-level variance of random
effect(s). Default is 1.}

\item{ivar}{Numeric. Individual-level variance. Default
is 1.}

\item{xVary}{Logical. Does predictor \code{x} vary over time?
Default is \code{F}.}

\item{yType}{Numeric. Relationship between predictors
and outcome. Linear=1, exponential=2.
Default is Linear=1.}

\item{b0}{Numeric. True intercept of the model. Default
is 1.}

\item{b1}{Numeric. True effect of \code{x} on \code{y}.
Default is 1.}

\item{b2}{Numeric. True effect of \code{time} on \code{y}.
Default is 1.}
}
\value{
Dataframe of analysis results
\itemize{
\item \strong{Estimate} - Coefficient estimate
\item \strong{Std.Err} - Coefficient standard error
\item \strong{Test.Stat} - Coefficient test statistic
\item \strong{p.value} - Coefficient p-value
\item \strong{Variable} - Predictor term in model
\item \strong{Method} - Statistical analysis method
\item \strong{Conv} - Convergence/error codes or messages.
}
}
\description{
Simulates data for \strong{time}, a time (in)variant
predictor \strong{x}, and a \strong{response} dependent
on the marginal effects of \strong{x} and \strong{time}.
Then applies various analytical methods.
}
\details{
\strong{Size of data:} Determined by number of samples
(clusters) and the number of waves (timepoints).

\strong{Time intervals:} Time is spaced in 1-unit
increments

\strong{Predictor variable:} The predictor \strong{x}
is fixed to a standard normal distribution.

\strong{Random effects:} Random effects define group
structure/dependency. Group-level/cluster-level
effects are Level 2 effects. Observation-level effects
are Level 1 effects. In longitudinal data, the "group"
is a single individual. The "observations" are the unique
measurements from a given individual at a given time.
This simulation only generates a random intercept (RI) per cluster
drawn from a normal distribution centered at 0 with
user-specified standard deviation. The greater the variance of
the Level 2 effects, relative to the Level 1 variation,
the more similar the values within a group.

\strong{Data generation:} Data is generated as a linear
combination of \code{x}, \code{time}, a random intercept (RI)
and individual level error (E). The relationship
between \code{y} and predictors \code{x} and \code{time}
can be linear or exponential.

\deqn{y = b0 + b1x + b2time + RI + E}
\deqn{y = b0 + b1x + e^{b2time} + RI + E}

The following methods are then applied to the data:

\strong{Naive linear regression (NLR):} Ignores clustering and time
when regressing outcome on predictor(s).

\strong{Cluster robust standard error (CRSE):} Applies a CRSE correction
to the standard errors of the aforementioned NLR output. Clustering is the group
membership.

\strong{Aggregate linear regression (AGG):} Averages all variables over
time within each cluster. Regresses the average outcome against the
average predictor(s).

\strong{Linear mixed model (LMM):} Regresses outcome on the
predictor(s) and time, while accounting for group dependency
with random effects. Two models - LMM1 and LMM2 - are implemented.
LMM1 is the correctly specified model, while LMM2
evaluates the interaction between \strong{x} and
\strong{time}

The models tested are
\eqn{y = x} for NLR, CRSE, and AGG,
\eqn{y = x + time + (1|group)} for LMM1, and
\eqn{y = x + time + x*time + (1|group)} for LMM2

To fit models, CRSE uses \code{lmtest} and the clustered variance
estimator from \code{sandwich} using type "HC1".
LMM uses \code{lmer} and \code{lmerTest}.

In randomly generated \code{x} has no variation instead of
reporting results for each method, the function returns a
data.frame with an error code \code{99999} as all entries
in the return value.
}
\examples{
power_lda_noInt()
}
